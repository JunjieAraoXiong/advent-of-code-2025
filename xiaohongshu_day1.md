# AoC 2025 Day 1: 环形密码锁的秘密

## 问题描述 (Problem)

你面前有一个圆形密码盘，刻度 **0-99**（共100格），初始指针指向 **50**。

按照指令旋转：
- `R48` = 向右转 (顺时针) 48格
- `L30` = 向左转 (逆时针) 30格
- **循环机制**：超过99会回到0，低于0会回到99。

**挑战任务：**
1.  **Part 1:** 执行完每次旋转后，指针**最终停在0**的次数是多少？
2.  **Part 2:** 旋转过程中，指针**经过0**的总次数是多少？（包括停在0的情况）

---

## 可视化 (Visualization)

想象一个只有100个刻度的时钟：

```text
        0  (起点/终点)
      .   .
   90       10
  .           .
75      *      25
  .     50    .
   60       40
      .   .
        50
```

- **R (Right/顺时针):** 数字增加 (50 -> 51 -> ... -> 99 -> 0 -> 1)
- **L (Left/逆时针):** 数字减少 (50 -> 49 -> ... -> 0 -> 99 -> 98)

---

## 解题思路 (Approach)

### Part 1: 模拟位置 (Simulation)

这部分比较直观，只需要跟踪当前位置。

> **核心公式：**
> Python 的 `%` 模运算非常强大，可以自动处理负数循环！
> `(0 - 5) % 100 = 95` (完美符合向左转的逻辑)

```python
position = 50  # 初始位置

for 指令 in 指令集:
    if 方向 == 'R':
        position = (position + distance) % 100
    else:  # 'L'
        position = (position - distance) % 100
        
    if position == 0:
        count += 1
```

---

### Part 2: 穿越次数 (Crossing Zero)

这里是难点！我们需要计算**动作过程中**经过了多少次0。

#### 1. 向右转 (Right)
向右转是数字增加的方向 (99 -> 0)。
每走100步，就会经过一次0。

- **公式：** `(当前位置 + 步数) // 100`
- **例子：** 在95的位置，R10。
  - 走到100步时（即走5步）经过0。
  - `(95 + 10) // 100 = 1`

#### 2. 向左转 (Left)
向左转是数字减少的方向 (1 -> 0 -> 99)。
这里有一个**超级易错点**！

> **关键坑点：**
> 如果你当前就在 **0** 的位置，向左走 (0 -> 99) 是**离开** 0，不算穿越！
> 只有当你绕了一整圈再次回到 0 时，才算第一次穿越。

**逻辑拆解：**

1.  **如果当前在 0：**
    - 你必须走满100步才能再次回到0。
    - `穿越次数 = distance // 100`
2.  **如果当前不在 0：**
    - 你需要先走 `position` 步回到0（这是第1次穿越）。
    - 剩下的步数每100步算一次。
    - `穿越次数 = (distance - position) // 100 + 1` (前提是步数够大)

```python
# 核心代码逻辑
if direction == 'R':
    crosses = (position + distance) // 100
else: # 'L'
    if position == 0:
        crosses = distance // 100
    elif distance >= position:
        crosses = (distance - position) // 100 + 1
    else:
        crosses = 0
```

---

## 示例解析 (Example Walkthrough)

假设起始位置 **50**，指令：`L68, R48`

| 步骤 | 指令 | 动作分析 | 穿越0? | 最终位置 |
|-----|------|----------|--------|----------|
| 1 | `L68` | 50向左走68步。<br>50 -> 0 需要50步 (穿越1次)。<br>剩下18步继续走到 82。 | **1** | 82 |
| 2 | `R48` | 82向右走48步。<br>82 -> 0 需要18步 (穿越1次)。<br>刚好停在 0。 | **1** | 0 |

---

## 复杂度与总结

- **时间复杂度:** O(N)，N是指令数。我们需要遍历每个指令一次。
- **空间复杂度:** O(1)，只需要存储当前位置和计数器。

**心得：**
Part 2 的难点在于对“边界条件”的理解。在环形数组或循环队列的问题中，**“起点即终点”**的情况往往需要特殊处理。画图模拟一下 0 -> 99 的过程非常有帮助！

---
🔗 **代码仓库:** [GitHub Link](https://github.com/JunjieAraoXiong/advant-of-code-2025)
