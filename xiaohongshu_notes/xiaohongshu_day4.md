# 📦 AoC 2025 Day 4: 仓库里的纸卷搬运

## 📝 问题描述 (Problem)

仓库里堆满了卷纸（用 `@` 表示），排列在一个网格上。叉车需要把纸卷搬走。

**搬运规则：** 叉车只能取走**周围8格中纸卷少于4个**的纸卷。

**挑战任务：**
1. **Part 1:** 初始状态下，有多少卷纸可以被取走？
2. **Part 2:** 取走纸卷后，原本被"包围"的纸卷可能变得可取。反复取走所有可取的纸卷，直到没有为止。问：**总共**能取走多少卷？

---

## 🎨 可视化 (Visualization)

### 8个邻居方向

```text
↖ ↑ ↗
← @ →
↙ ↓ ↘
```

每个纸卷最多有8个邻居。边缘和角落的纸卷邻居更少，更容易被取走！

### 示例网格

```text
初始状态:          可取的标记为 X:
..@@.@@@@.         ..XX.XX@X.
@@@.@.@.@@         X@@.@.@.@@
@@@@@.@.@@         @@@@@.X.@@
@.@@@@..@.         @.@@@@..@.
@@.@@@@.@@         X@.@@@@.@X
.@@@@@@@.@         .@@@@@@@.@
.@.@.@.@@@         .@.@.@.@@@
@.@@@.@@@@         X.@@@.@@@@
.@@@@@@@@.         .@@@@@@@@.
@.@.@@@.@.         X.X.@@@.X.
```

**Part 1 答案：13** 个可取

---

## 💡 解题思路 (Approach)

### Part 1: 邻居计数

> 🔑 **核心思想：**
> 遍历每个 `@`，数它周围8个方向有多少个 `@`。
> 如果少于4个，这个纸卷可以取走。

```python
directions = [
    (-1,-1), (-1,0), (-1,1),  # 上排
    (0,-1),          (0,1),   # 左右
    (1,-1),  (1,0),  (1,1)    # 下排
]

def count_neighbors(grid, row, col):
    count = 0
    for dr, dc in directions:
        nr, nc = row + dr, col + dc
        if 0 <= nr < rows and 0 <= nc < cols:
            if grid[nr][nc] == '@':
                count += 1
    return count

# 主逻辑
accessible = 0
for r in range(rows):
    for c in range(cols):
        if grid[r][c] == '@':
            if count_neighbors(grid, r, c) < 4:
                accessible += 1
```

---

### Part 2: 循环移除模拟

> 🔑 **核心思想：**
> 每轮找出所有可取的纸卷 → 全部移除 → 重复直到没有可取的。

```python
def solve_part2(grid):
    grid = [list(row) for row in grid]  # 转为可修改
    total_removed = 0

    while True:
        # 找出本轮所有可取的
        accessible = find_all_accessible(grid)

        if not accessible:
            break  # 没有可取的了

        # 移除它们
        for r, c in accessible:
            grid[r][c] = '.'

        total_removed += len(accessible)

    return total_removed
```

---

## 📊 移除过程演示 (Step-by-Step)

```text
Round 1: 移除 13 个 (边缘的)
..XX.XX@X.  →  .......@..
X@@.@.@.@@     .@@.@.@.@@
...

Round 2: 移除 12 个 (新暴露的边缘)
.......X..  →  ..........
.@@.X.X.@X     .@@.....@.
...

Round 3: 移除 7 个
...

... 继续直到稳定 ...

最终状态 (无法再移除):
..........
..........
..........
...@@@....    ← 剩下的纸卷
...@@@@...      每个都有4+邻居
...@@@@@..      形成稳定结构
...@.@.@@.
...@@.@@@.
...@@@@@..
....@@@...
```

### 统计表

| 轮次 | 移除数 | 累计移除 | 剩余 |
|-----|--------|---------|------|
| 1 | 13 | 13 | 58 |
| 2 | 12 | 25 | 46 |
| 3 | 7 | 32 | 39 |
| 4 | 5 | 37 | 34 |
| 5 | 2 | 39 | 32 |
| 6 | 1 | 40 | 31 |
| 7 | 1 | 41 | 30 |
| 8 | 1 | 42 | 29 |
| 9 | 1 | **43** | 28 |
| 停止 | 0 | - | 28 (稳定) |

**Part 2 答案：43** 个总共被移除

---

## 🧠 为什么会形成稳定结构？

当剩余的纸卷形成一个**紧密的块**时：
- 每个纸卷都被4个以上邻居包围
- 没有"边缘"可以突破
- 叉车无法再取走任何一个

```text
稳定的 3x3 块:
@@@
@@@  ← 中心有8个邻居，角落有3个但被保护
@@@

不稳定 (有突出):
@@@
@@   ← 右边缺口会导致连锁移除
@@@
```

---

## 🚀 复杂度分析

| Part | 时间复杂度 | 说明 |
|------|-----------|------|
| 1 | O(R × C) | 遍历网格一次 |
| 2 | O((R × C)²) | 最坏情况每轮移除1个 |

实际运行中，每轮通常移除多个，所以比最坏情况快很多。

---

## 🎮 运行可视化

代码支持 `--visual` 参数，可以看到逐步移除的动画：

```bash
python solution.py --visual
```

输出示例：
```text
Iteration 1: Found 13 accessible rolls (marked X)
..XX.XX@X.
X@@.@.@.@@
...

After removal: 13 removed, 58 remaining
```

---

## 📝 总结

| 概念 | Part 1 | Part 2 |
|------|--------|--------|
| 问的是 | 初始可取数量 | 总共可取数量 |
| 方法 | 单次遍历计数 | 循环模拟移除 |
| 关键 | 8方向邻居检查 | 移除后重新计算 |

**心得：**
这道题很像"生命游戏"(Game of Life)的变体。关键是理解：
1. 移除是**同时发生**的（先找出所有可取的，再一起移除）
2. 稳定结构的形成条件（每个成员都有足够邻居保护）

类似问题：细胞自动机、洪水填充、连通分量分析。

---

🔗 **代码仓库:** [GitHub Link](https://github.com/JunjieAraoXiong/advant-of-code-2025)
