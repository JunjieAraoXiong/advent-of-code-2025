# 🔋 AoC 2025 Day 3: 电池选择的贪心策略

## 📝 问题描述 (Problem)

仓库里有很多电池组（每行是一个电池组），每个电池上标有数字 **1-9**。

你需要从每个电池组中选择 **K** 个电池，按顺序拼成一个数字（称为"电压值"）。

**挑战任务：**
1. **Part 1:** K = 2，选2个电池，求所有电池组的最大电压值之和
2. **Part 2:** K = 12，选12个电池，求所有电池组的最大电压值之和

**关键约束：** 选择的电池必须**保持原有顺序**！

---

## 🎨 可视化 (Visualization)

假设电池组是 `"987654321111119"`，选择 K=2 个电池：

```text
电池组: 9 8 7 6 5 4 3 2 1 1 1 1 1 1 9
位置:   0 1 2 3 4 5 6 7 8 9 ...    14

要组成最大的两位数 AB：
- A 要尽量大（十位最重要）
- B 要尽量大（在 A 之后选）

最优选择：选位置 0 的 '9' 和位置 14 的 '9'
结果：99 ✅
```

---

## 💡 解题思路 (Approach)

### Part 1: 两位数最大化 (K=2)

#### 暴力解法 O(n²) ❌

```python
# 尝试所有配对
for i in range(n):
    for j in range(i+1, n):
        joltage = int(bank[i]) * 10 + int(bank[j])
        best = max(best, joltage)
```

对于很长的字符串会超时！

#### 优化解法 O(n) ✅

> 🔑 **核心思想：**
> 对于每个位置 i，我们只关心它**后面**的最大数字是什么。
> 预计算 `max_after[i]` = 位置 i 之后的最大数字

```python
def max_joltage_k2(bank):
    n = len(bank)

    # 从右往左扫描，预计算每个位置后面的最大值
    max_after = [0] * n
    max_so_far = 0
    for i in range(n-1, -1, -1):
        max_after[i] = max_so_far
        max_so_far = max(max_so_far, int(bank[i]))

    # 遍历每个位置作为第一个数字
    best = 0
    for i in range(n-1):
        joltage = int(bank[i]) * 10 + max_after[i]
        best = max(best, joltage)

    return best
```

**示例：** `"811111111111119"`

| 位置 | 数字 | max_after | 电压值 |
|-----|------|-----------|--------|
| 0 | 8 | 9 | **89** ✅ |
| 1 | 1 | 9 | 19 |
| ... | 1 | 9 | 19 |

最优答案：**89**（选位置0和位置14）

---

### Part 2: K位数最大化 (K=12)

当 K 很大时，需要**贪心算法**！

> 🔑 **贪心策略：**
> 从左到右依次选择每一位数字。
> 每次在**合法范围内**选择最大的数字。

#### 什么是"合法范围"？

选第 i 个数字时（0-indexed），后面还需要选 K-i-1 个数字。
所以当前选择范围是 `[start, n - (K - i - 1) - 1]`

```text
电池组长度: 15
需要选择: 12 个
需要跳过: 15 - 12 = 3 个

第1个数字: 可选范围 [0, 3]  (要留12-1=11个位置)
第2个数字: 可选范围 [上次+1, 4]
第3个数字: 可选范围 [上次+1, 5]
...
```

#### 代码实现

```python
def max_joltage_k(bank, k):
    n = len(bank)
    result = []
    start = 0

    for i in range(k):
        # 当前可选的最后位置
        end = n - k + i

        # 在 [start, end] 范围内找最大数字
        best_pos = start
        best_digit = bank[start]
        for pos in range(start, end + 1):
            if bank[pos] > best_digit:
                best_digit = bank[pos]
                best_pos = pos

        result.append(best_digit)
        start = best_pos + 1  # 下一个必须在这之后

    return int(''.join(result))
```

---

## 📊 示例解析 (Example Walkthrough)

电池组：`"818181911112111"` (长度15)，K=12

```text
需要跳过 3 个数字，选 12 个。

第1轮: 范围[0,3] = "8181" → 选 8 (位置0)
第2轮: 范围[1,4] = "1818" → 选 8 (位置2)
第3轮: 范围[3,5] = "181"  → 选 8 (位置4)
第4轮: 范围[5,6] = "19"   → 选 9 (位置6) 🎉
第5轮: 范围[7,7] = "1"    → 选 1 (位置7)
...后面依次选完

结果: 888911112111 ✅
```

可视化选择过程：

```text
原始: 8 1 8 1 8 1 9 1 1 1 1 2 1 1 1
      ^   ^   ^   ^
      选  选  选  选 ...

选中: 8   8   8   9 1 1 1 1 2 1 1 1
结果: 888911112111
```

---

## 🚀 复杂度分析

| Part | 时间复杂度 | 说明 |
|------|-----------|------|
| 1 | O(n) | 预计算 + 一次遍历 |
| 2 | O(K × n) | K轮，每轮最多扫n个 |

对于 K=12，复杂度是 O(12n) ≈ O(n)，完全可接受！

---

## 🧠 为什么贪心是对的？

1. **最高位最重要**：12位数中，第1位代表10¹¹，远大于后面所有位之和
2. **局部最优 = 全局最优**：每次选最大的不会影响后续选择的可能性（只要保证留够位置）
3. **无后效性**：选完第 i 位后，问题变成"在剩余中选 K-i-1 位"，子问题结构相同

---

## 📝 总结

| 概念 | Part 1 (K=2) | Part 2 (K=12) |
|------|--------------|---------------|
| 策略 | 预计算后缀最大值 | 贪心逐位选择 |
| 核心 | max_after 数组 | 维护合法选择范围 |
| 复杂度 | O(n) | O(K × n) |

**心得：**
这道题的关键是理解"保持顺序"的约束。贪心能成功是因为数字的位置权重从高到低，选择互不干扰。类似的问题还有"从数组中选K个数组成最大数"。

---

🔗 **代码仓库:** [GitHub Link](https://github.com/JunjieAraoXiong/advant-of-code-2025)
