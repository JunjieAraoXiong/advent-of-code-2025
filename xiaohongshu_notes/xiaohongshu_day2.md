# AoC 2025 Day 2: 礼品店的神秘代码

## 问题描述 (Problem)

礼品店发现了一批**无效的产品ID**，需要紧急召回！
如果一个ID是由**重复的数字模式**组成的，它就是无效的。

给你一系列ID范围（例如 `10-100`），请找出所有无效ID并求和。

**挑战任务：**
1.  **Part 1:** 模式**恰好重复2次** → 无效 (e.g., `1212`)
2.  **Part 2:** 模式**重复2次或更多** → 无效 (e.g., `121212`)

---

## 模式图解 (Pattern Visualization)

| 类型 | 规则 | 示例 (无效) | 示例 (有效) |
|------|------|--------------|--------------|
| **Part 1** | 恰好重复 2 次 | `55` ("5"x2)<br>`123123` ("123"x2) | `111` ("1"x3)<br>`123` (无重复) |
| **Part 2** | 重复 2 次及以上 | `55` ("5"x2)<br>`111` ("1"x3)<br>`121212` ("12"x3) | `123` (无重复)<br>`1001` (不对称) |

---

## 解题思路 (Approach)

### 核心难点：范围太大了！
题目给出的范围可能非常巨大（例如 `1` 到 `100亿`）。
如果用普通的 `for` 循环遍历每个数字去检查，程序可能要跑好几天！

> **逆向思维 (Optimization):**
> 不要去检查每个数字是否无效。
> 而是**直接生成**所有无效的数字，然后看它们是否在范围内。
>
> - **遍历法:** 检查 100亿 个数字 (超时)
> - **生成法:** 只需要生成 约10万 个无效数字 (秒杀)

---

### Part 1: 生成重复2次的ID

只需要生成前半部分，然后复制一遍即可！

**步骤：**
1.  枚举可能的位数 (2位, 4位, 6位...)。
2.  生成前半部分 `half`。
3.  拼接 `half + half` 得到无效ID。

```python
# 生成逻辑示例
half = "12"
invalid_id = int(half + half) # 1212

if start <= invalid_id <= end:
    valid_list.append(invalid_id)
```

---

### Part 2: 生成重复2次+的ID

这里有一个**超级大坑**！

> **坑点：重复计数 (Duplicates)**
> 同一个数字可能由不同的模式生成！
> - `1111` 可以看作 `"1"` 重复4次
> - `1111` 也可以看作 `"11"` 重复2次
>
> **解决方案：** 使用 `Set` (集合) 来自动去重！

**生成逻辑：**
1.  枚举总位数 `total_digits`。
2.  枚举可能的模式长度 `pattern_len` (必须能整除总位数)。
3.  生成模式 `pattern`，重复 `k` 次得到无效ID。

```python
invalid_ids = set() # 使用 set 去重

# 示例：生成 6位数的无效ID
# 模式长度可以是 1 (重复6次), 2 (重复3次), 3 (重复2次)

pattern = "12"
reps = 3
id = int(pattern * reps) # 121212 -> 加入集合
```

---

## 复杂度对比

| 方法 | 时间复杂度 | 10位数的计算量 | 结果 |
|------|-----------|---------------|------|
| **暴力检查** | O(N) | 10,000,000,000 次 | 超时 |
| **生成法** | O(10^(D/2)) | ~100,000 次 | <0.1秒 |

---

## 关键代码片段

```python
def find_invalid_part2(start, end):
    invalid_ids = set()
    
    # 遍历所有可能的总长度
    for total_len in range(2, len(str(end)) + 2):
        # 遍历所有可能的模式长度
        for p_len in range(1, total_len // 2 + 1):
            if total_len % p_len != 0: continue
            
            # 生成模式并重复
            min_p = 10**(p_len-1)
            max_p = 10**p_len - 1
            
            for p in range(min_p, max_p + 1):
                num = int(str(p) * (total_len // p_len))
                if start <= num <= end:
                    invalid_ids.add(num)
                    
    return sum(invalid_ids)
```

---

## 总结

1.  **逆向思维**是解决大范围问题的关键。
2.  **Set (集合)** 是处理重复统计的神器。
3.  **数学规律** (整除性) 能帮助我们快速筛选有效的模式长度。

---
🔗 **代码仓库:** [GitHub Link](https://github.com/JunjieAraoXiong/advant-of-code-2025)
